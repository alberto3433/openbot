<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Order Bot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
    }
    .app-header {
      background: #1976d2;
      color: white;
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 18px;
      font-weight: 600;
    }
    .app-header span.sub {
      font-size: 13px;
      font-weight: 400;
      opacity: 0.9;
    }
    .chat-container {
      max-width: 900px;
      margin: 20px auto;
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      height: calc(100vh - 80px);
      overflow: hidden;
    }
    .chat-header {
      padding: 10px 16px;
      text-align: center;
      font-size: 13px;
      color: #666;
      border-bottom: 1px solid #eee;
    }
    .chat-messages {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      background: #fafafa;
    }
    .msg-row {
      display: flex;
      margin-bottom: 10px;
    }
    .msg-row.user {
      justify-content: flex-end;
    }
    .msg-row.assistant {
      justify-content: flex-start;
    }
    .msg-bubble {
      max-width: 70%;
      padding: 10px 14px;
      border-radius: 16px;
      font-size: 14px;
      line-height: 1.4;
    }
    .msg-row.user .msg-bubble {
      background: #1976d2;
      color: white;
      border-bottom-right-radius: 4px;
    }
    .msg-row.assistant .msg-bubble {
      background: white;
      border: 1px solid #e0e0e0;
      border-bottom-left-radius: 4px;
    }
    .chat-footer {
      border-top: 1px solid #eee;
      padding: 10px;
      display: flex;
      gap: 8px;
      background: #fff;
    }
    .chat-footer input[type="text"] {
      flex: 1;
      border-radius: 20px;
      border: 1px solid #ccc;
      padding: 8px 12px;
      font-size: 14px;
      outline: none;
    }
    .chat-footer button {
      border-radius: 20px;
      border: none;
      background: #1976d2;
      color: white;
      padding: 0 18px;
      font-size: 14px;
      cursor: pointer;
    }
    .chat-footer button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    .status-bar {
      font-size: 12px;
      color: #777;
      padding: 4px 16px 8px;
    }
    /* Caller ID simulation */
    .caller-id-panel {
      padding: 10px 16px;
      background: #fff3cd;
      border-bottom: 1px solid #ffc107;
      font-size: 13px;
    }
    .caller-id-panel summary {
      cursor: pointer;
      color: #856404;
      font-weight: 500;
    }
    .caller-id-panel summary:hover {
      text-decoration: underline;
    }
    .caller-id-content {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .caller-id-content input {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 13px;
    }
    .caller-id-content button {
      padding: 6px 12px;
      background: #ffc107;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
    }
    .caller-id-content button:hover {
      background: #e0a800;
    }
    .returning-customer-badge {
      background: #28a745;
      color: white;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 11px;
      margin-left: 8px;
    }
    /* Typing indicator styles */
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 10px 14px;
    }
    .typing-indicator .dot {
      width: 8px;
      height: 8px;
      background: #999;
      border-radius: 50%;
      animation: typing-bounce 1.4s infinite ease-in-out both;
    }
    .typing-indicator .dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-indicator .dot:nth-child(2) { animation-delay: -0.16s; }
    .typing-indicator .dot:nth-child(3) { animation-delay: 0s; }
    @keyframes typing-bounce {
      0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
      40% { transform: scale(1); opacity: 1; }
    }
    /* TTS Controls */
    .tts-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 16px;
      background: #f0f7ff;
      border-bottom: 1px solid #d0e3f7;
      font-size: 13px;
    }
    .tts-controls label {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #1565c0;
    }
    .tts-controls select {
      padding: 4px 8px;
      border: 1px solid #90caf9;
      border-radius: 4px;
      font-size: 12px;
      background: white;
    }
    .tts-mute-btn {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border: 1px solid #90caf9;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 12px;
      color: #1565c0;
      transition: all 0.2s;
    }
    .tts-mute-btn:hover {
      background: #e3f2fd;
    }
    .tts-mute-btn.muted {
      background: #ffebee;
      border-color: #ef9a9a;
      color: #c62828;
    }
    .tts-mute-btn .icon {
      font-size: 16px;
    }
    .tts-status {
      margin-left: auto;
      font-size: 11px;
      color: #666;
    }
    .tts-status.speaking {
      color: #2e7d32;
    }
    .tts-status.error {
      color: #c62828;
    }
  </style>
</head>
<body>
  <div class="app-header">
    <div>Order Bot</div>
    <span class="sub">Demo web chat Â· Local FastAPI backend</span>
  </div>

  <div class="chat-container">
    <!-- Caller ID Simulation Panel (Dev/Demo Mode) -->
    <details class="caller-id-panel" id="caller-id-panel">
      <summary>Simulate Incoming Call (Dev Mode)</summary>
      <div class="caller-id-content">
        <label for="store-select" style="white-space: nowrap;">Store:</label>
        <select id="store-select" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
          <!-- Populated dynamically from localStorage -->
        </select>
      </div>
      <div class="caller-id-content" style="margin-top: 8px;">
        <input
          type="tel"
          id="caller-id-input"
          placeholder="Enter phone number (e.g., 555-123-4567)"
        />
        <button type="button" id="start-with-caller-id">Start Call</button>
      </div>
      <div style="margin-top: 6px; color: #666; font-size: 12px;">
        Select a store and optionally enter a phone number. URL params: <code>?store=store_eb_001&caller_id=555-123-4567</code>
      </div>
    </details>

    <!-- TTS Voice Controls -->
    <div class="tts-controls" id="tts-controls">
      <label>
        <span class="icon">ðŸ”Š</span>
        Voice:
        <select id="tts-voice-select">
          <option value="">Loading voices...</option>
        </select>
      </label>
      <button type="button" class="tts-mute-btn" id="tts-mute-btn" title="Toggle voice on/off">
        <span class="icon">ðŸ”Š</span>
        <span class="label">Voice On</span>
      </button>
      <span class="tts-status" id="tts-status"></span>
    </div>

    <div class="chat-header" id="chat-header">
      Connecting...
    </div>
    <div class="chat-messages" id="chat-messages"></div>
    <div class="status-bar" id="status-bar">Disconnected</div>
    <form class="chat-footer" id="chat-form">
      <input
        type="text"
        id="chat-input"
        autocomplete="off"
        placeholder="Type your message..."
      />
      <button type="submit">Send</button>
    </form>
  </div>

  <script>
    const messagesEl = document.getElementById("chat-messages");
    const headerEl = document.getElementById("chat-header");
    const statusEl = document.getElementById("status-bar");
    const formEl = document.getElementById("chat-form");
    const inputEl = document.getElementById("chat-input");
    const callerIdPanel = document.getElementById("caller-id-panel");
    const callerIdInput = document.getElementById("caller-id-input");
    const storeSelect = document.getElementById("store-select");
    const startWithCallerIdBtn = document.getElementById("start-with-caller-id");

    // Store name mapping (built dynamically)
    let STORE_NAMES = {};

    // Company info (loaded from API)
    let companyInfo = {
      name: "Sammy's Subs",
      bot_persona_name: "Sammy",
      primary_item_type: "Sandwich"
    };

    // Load company info from API
    async function loadCompanyInfo() {
      try {
        const response = await fetch("/company");
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        companyInfo = await response.json();
        console.log("[Company] Loaded company info:", companyInfo.name);

        // Update page title and header with dynamic item type (Pizza Bot, Sandwich Bot, etc.)
        const itemType = companyInfo.primary_item_type || "Sandwich";
        document.title = `${companyInfo.bot_persona_name} the ${itemType} Bot`;
        document.querySelector(".app-header > div").textContent =
          `${companyInfo.bot_persona_name} the ${itemType} Bot`;

        return companyInfo;
      } catch (error) {
        console.error("[Company] Failed to load company info:", error);
        // Keep defaults
        return companyInfo;
      }
    }

    // Load stores from API and populate dropdown
    async function loadStoresAndPopulateDropdown() {
      let stores = [];

      try {
        // Fetch available (open, non-deleted) stores from API
        const response = await fetch("/stores");
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        stores = await response.json();
        console.log("[Store Loader] Loaded stores from API:", stores.length);
      } catch (error) {
        console.error("[Store Loader] Failed to load stores from API:", error);
        // Fallback to defaults if API fails
        stores = [
          { store_id: "store_eb_001", name: "Sammy's Subs - East Brunswick" },
          { store_id: "store_nb_002", name: "Sammy's Subs - New Brunswick" }
        ];
      }

      // Map API response to available stores (already filtered by API)
      const availableStores = stores.map(s => ({
        id: s.store_id,
        name: s.name
      }));

      console.log("[Store Loader] Available stores:", availableStores.length);

      // Build STORE_NAMES mapping
      STORE_NAMES = {};
      availableStores.forEach(store => {
        // Extract short name (e.g., "East Brunswick" from "Sammy's Subs - East Brunswick")
        const shortName = store.name.includes(" - ")
          ? store.name.split(" - ").pop()
          : store.name;
        STORE_NAMES[store.id] = shortName;
      });

      // Populate dropdown
      storeSelect.innerHTML = "";
      if (availableStores.length === 0) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No stores available";
        storeSelect.appendChild(opt);
      } else {
        availableStores.forEach(store => {
          const opt = document.createElement("option");
          opt.value = store.id;
          opt.textContent = STORE_NAMES[store.id];
          storeSelect.appendChild(opt);
        });
      }

      return availableStores;
    }

    let sessionId = null;
    let connected = false;
    let currentCallerId = null;
    let currentStoreId = null;

    let typingIndicatorEl = null;

    // Analytics tracking
    let sessionStartTime = null;
    let messageCount = 0;
    let orderState = { status: "pending", items: [], total_price: 0 };
    let lastBotMessage = null;
    let lastUserMessage = null;
    let orderConfirmed = false;
    let conversationHistory = [];  // Track full conversation for analytics

    function addMessage(role, text) {
      const row = document.createElement("div");
      row.className = "msg-row " + role;

      const bubble = document.createElement("div");
      bubble.className = "msg-bubble";
      bubble.textContent = text;

      row.appendChild(bubble);
      messagesEl.appendChild(row);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function showTypingIndicator() {
      if (typingIndicatorEl) return; // Already showing

      const row = document.createElement("div");
      row.className = "msg-row assistant";

      const bubble = document.createElement("div");
      bubble.className = "msg-bubble typing-indicator";
      bubble.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';

      row.appendChild(bubble);
      messagesEl.appendChild(row);
      messagesEl.scrollTop = messagesEl.scrollHeight;

      typingIndicatorEl = row;
    }

    function hideTypingIndicator() {
      if (typingIndicatorEl) {
        typingIndicatorEl.remove();
        typingIndicatorEl = null;
      }
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    async function startSession(callerId = null, storeId = null) {
      try {
        setStatus("Starting session...");

        // Build URL with optional parameters
        let url = "/chat/start";
        const params = new URLSearchParams();
        if (callerId) {
          params.append("caller_id", callerId);
          currentCallerId = callerId;
        }
        if (storeId) {
          params.append("store_id", storeId);
          currentStoreId = storeId;
        }
        if (params.toString()) {
          url += "?" + params.toString();
        }

        const resp = await fetch(url, {
          method: "POST",
        });
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        const data = await resp.json();
        sessionId = data.session_id;
        connected = true;
        sessionStartTime = Date.now();

        // Update header with store and caller ID info
        let headerText = "Session: " + sessionId.substring(0, 8);
        if (storeId && STORE_NAMES[storeId]) {
          headerText += ` | ${STORE_NAMES[storeId]}`;
        }
        if (callerId) {
          headerText += ` | Caller: ${callerId}`;
        }
        if (data.returning_customer && data.returning_customer.name) {
          headerText += ` | ${data.returning_customer.name}`;
          // Add returning customer badge
          headerEl.innerHTML = headerText + '<span class="returning-customer-badge">Returning Customer</span>';
        } else {
          headerEl.textContent = headerText;
        }

        setStatus("Connected");

        // Collapse the caller ID panel after starting
        callerIdPanel.removeAttribute("open");

        // ðŸ”¹ Show Sammy's initial greeting from backend
        if (data.message) {
          addMessage("assistant", data.message);
          lastBotMessage = data.message;
          messageCount++;
          conversationHistory.push({ role: "assistant", content: data.message });
        }

        // Log returning customer info if present
        if (data.returning_customer) {
          console.log("Returning customer:", data.returning_customer);
        }
      } catch (err) {
        console.error("Error starting session:", err);
        headerEl.textContent = "Error starting session";
        setStatus("Failed to connect");
      }
    }

    async function sendMessage(text) {
      if (!sessionId) {
        console.warn("No sessionId yet");
        return;
      }
      addMessage("user", text);
      lastUserMessage = text;
      messageCount++;
      conversationHistory.push({ role: "user", content: text });
      setStatus("Sending...");
      showTypingIndicator();

      try {
        const resp = await fetch("/chat/message", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId, message: text }),
        });
        hideTypingIndicator();
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        const data = await resp.json();
        if (data.reply) {
          addMessage("assistant", data.reply);
          lastBotMessage = data.reply;
          messageCount++;
          conversationHistory.push({ role: "assistant", content: data.reply });
        }
        // Track order state for analytics
        if (data.order_state) {
          orderState = data.order_state;
          if (orderState.status === "confirmed") {
            orderConfirmed = true;
          }
        }
        setStatus("Connected");
      } catch (err) {
        hideTypingIndicator();
        console.error("Error sending message:", err);
        addMessage("assistant", "Oops, something went wrong talking to the backend.");
        setStatus("Backend error");
      }
    }

    formEl.addEventListener("submit", (e) => {
      e.preventDefault();
      const text = inputEl.value.trim();
      if (!text) return;
      inputEl.value = "";
      sendMessage(text);
    });

    // Handle "Start Call" button click with caller ID and store
    startWithCallerIdBtn.addEventListener("click", () => {
      const callerId = callerIdInput.value.trim();
      const storeId = storeSelect.value;

      // Reset session state if we already had a session
      if (sessionId) {
        sessionId = null;
        connected = false;
        messagesEl.innerHTML = "";
        messageCount = 0;
        orderState = { status: "pending", items: [], total_price: 0 };
        lastBotMessage = null;
        lastUserMessage = null;
        orderConfirmed = false;
        conversationHistory = [];
        abandonAnalyticsSent = false;
      }
      startSession(callerId || null, storeId);
    });

    // Start session on page load - check URL params first
    window.addEventListener("load", async () => {
      // Load company info first (updates page title/header)
      await loadCompanyInfo();

      // Load TTS voices (so greeting can be spoken)
      await loadTTSVoices();

      // Load stores from API and populate dropdown
      const availableStores = await loadStoresAndPopulateDropdown();

      const urlParams = new URLSearchParams(window.location.search);
      const storeIdParam = urlParams.get("store") || urlParams.get("store_id");
      const callerIdParam = urlParams.get("caller_id");

      // Set dropdown value if store param provided and store is available
      if (storeIdParam && STORE_NAMES[storeIdParam]) {
        storeSelect.value = storeIdParam;
      }

      // Set caller ID input if provided
      if (callerIdParam) {
        callerIdInput.value = callerIdParam;
      }

      // Start session with params (store defaults to first option if not specified)
      const storeId = storeIdParam && STORE_NAMES[storeIdParam] ? storeIdParam : storeSelect.value;
      if (storeId) {
        startSession(callerIdParam || null, storeId);
      } else {
        headerEl.textContent = "No stores available";
        setStatus("Please add stores in Store Management");
      }
    });

    // Track abandoned sessions (simulates "hang up")
    let abandonAnalyticsSent = false;  // Prevent duplicate sends

    function sendAbandonAnalytics(reason) {
      // Don't send if already sent, no session, or order was confirmed
      if (abandonAnalyticsSent || !sessionId || orderConfirmed) {
        return;
      }

      abandonAnalyticsSent = true;  // Mark as sent to prevent duplicates

      const items = orderState.items || [];
      const sessionDuration = sessionStartTime
        ? Math.floor((Date.now() - sessionStartTime) / 1000)
        : null;

      const payload = {
        session_id: sessionId,
        message_count: messageCount,
        had_items_in_cart: items.length > 0,
        item_count: items.length,
        cart_total: orderState.total_price || 0,
        order_status: orderState.status || "pending",
        last_bot_message: lastBotMessage,
        last_user_message: lastUserMessage,
        reason: reason,
        session_duration_seconds: sessionDuration,
        conversation_history: conversationHistory,  // Include full conversation
        store_id: currentStoreId,  // Include store for analytics
      };

      // Use sendBeacon for reliability during page unload
      // It's fire-and-forget and works even when the page is closing
      const blob = new Blob([JSON.stringify(payload)], { type: "application/json" });
      navigator.sendBeacon("/chat/abandon", blob);

      console.log("Abandon analytics sent:", reason);
    }

    // Detect page unload (refresh, close, or navigation)
    // Use only beforeunload as it's most reliable and fires first
    window.addEventListener("beforeunload", (event) => {
      // Detect if this is a refresh vs close/navigation
      // Note: We can't perfectly distinguish close vs navigation in beforeunload
      sendAbandonAnalytics("browser_close");
    });

    // =====================================================
    // TTS (Text-to-Speech) Functionality
    // =====================================================

    const ttsVoiceSelect = document.getElementById("tts-voice-select");
    const ttsMuteBtn = document.getElementById("tts-mute-btn");
    const ttsStatus = document.getElementById("tts-status");

    // TTS State
    let ttsVoices = [];
    let ttsMuted = localStorage.getItem("tts_muted") === "true";
    let ttsSelectedVoice = localStorage.getItem("tts_voice") || null;
    let ttsAudio = null;  // Current audio element
    let ttsQueue = [];    // Queue of texts to speak
    let ttsSpeaking = false;
    let ttsReady = false; // Flag to track if TTS is initialized

    // Initialize mute button state
    function updateMuteButtonUI() {
      if (ttsMuted) {
        ttsMuteBtn.classList.add("muted");
        ttsMuteBtn.querySelector(".icon").textContent = "ðŸ”‡";
        ttsMuteBtn.querySelector(".label").textContent = "Voice Off";
      } else {
        ttsMuteBtn.classList.remove("muted");
        ttsMuteBtn.querySelector(".icon").textContent = "ðŸ”Š";
        ttsMuteBtn.querySelector(".label").textContent = "Voice On";
      }
    }

    // Load available voices from API
    async function loadTTSVoices() {
      try {
        const response = await fetch("/tts/voices");
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        ttsVoices = data.voices || [];

        // Populate voice dropdown
        ttsVoiceSelect.innerHTML = "";
        ttsVoices.forEach(voice => {
          const opt = document.createElement("option");
          opt.value = voice.id;
          // Format: "Nova (Female, American) - Friendly and upbeat"
          let label = voice.name;
          if (voice.gender || voice.accent) {
            const details = [voice.gender, voice.accent].filter(Boolean).join(", ");
            label += ` (${details})`;
          }
          if (voice.description) {
            label += ` - ${voice.description}`;
          }
          opt.textContent = label;
          ttsVoiceSelect.appendChild(opt);
        });

        // Restore saved voice selection or use default
        if (ttsSelectedVoice && ttsVoices.some(v => v.id === ttsSelectedVoice)) {
          ttsVoiceSelect.value = ttsSelectedVoice;
        } else if (ttsVoices.length > 0) {
          // Default to "nova" if available, otherwise first voice
          const defaultVoice = ttsVoices.find(v => v.id === "nova") || ttsVoices[0];
          ttsVoiceSelect.value = defaultVoice.id;
          ttsSelectedVoice = defaultVoice.id;
        }

        ttsReady = true;
        console.log(`[TTS] Loaded ${ttsVoices.length} voices from ${data.provider}, selected: ${ttsSelectedVoice}`);
      } catch (error) {
        console.error("[TTS] Failed to load voices:", error);
        ttsVoiceSelect.innerHTML = '<option value="">Voice unavailable</option>';
        setTTSStatus("Voice unavailable", "error");
        ttsReady = false;
      }
    }

    // Set TTS status message
    function setTTSStatus(message, type = "") {
      ttsStatus.textContent = message;
      ttsStatus.className = "tts-status" + (type ? ` ${type}` : "");
      // Auto-clear status after 3 seconds (unless it's an error)
      if (type !== "error" && message) {
        setTimeout(() => {
          if (ttsStatus.textContent === message) {
            ttsStatus.textContent = "";
            ttsStatus.className = "tts-status";
          }
        }, 3000);
      }
    }

    // Synthesize and play text
    async function speakText(text) {
      if (ttsMuted || !text) return;

      // Check if TTS is ready
      if (!ttsReady || !ttsSelectedVoice) {
        console.warn("[TTS] Not ready yet, skipping:", text.substring(0, 50) + "...");
        return;
      }

      // Add to queue
      ttsQueue.push(text);

      // If already speaking, the queue will be processed
      if (ttsSpeaking) return;

      await processQueue();
    }

    async function processQueue() {
      if (ttsQueue.length === 0) {
        ttsSpeaking = false;
        return;
      }

      ttsSpeaking = true;
      const text = ttsQueue.shift();

      try {
        setTTSStatus("Speaking...", "speaking");

        // Stop any currently playing audio
        if (ttsAudio) {
          ttsAudio.pause();
          ttsAudio = null;
        }

        // Call TTS API
        console.log("[TTS] Calling synthesize API with voice:", ttsSelectedVoice);
        const response = await fetch("/tts/synthesize", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            text: text,
            voice: ttsSelectedVoice,
            speed: 1.0
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error("[TTS] API error:", response.status, errorText);
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        // Get audio blob and play it
        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);

        ttsAudio = new Audio(audioUrl);

        // Clean up URL when done
        ttsAudio.onended = () => {
          URL.revokeObjectURL(audioUrl);
          setTTSStatus("");
          processQueue();  // Process next in queue
        };

        ttsAudio.onerror = (e) => {
          console.error("[TTS] Audio playback error:", e);
          URL.revokeObjectURL(audioUrl);
          setTTSStatus("Playback error", "error");
          processQueue();  // Continue with next item
        };

        // Handle mute during playback
        if (ttsMuted) {
          ttsAudio = null;
          setTTSStatus("");
          processQueue();
          return;
        }

        try {
          await ttsAudio.play();
        } catch (playError) {
          // Browser may block autoplay without user interaction
          if (playError.name === 'NotAllowedError') {
            console.warn("[TTS] Autoplay blocked by browser - waiting for user interaction");
            setTTSStatus("Click to enable voice", "error");
            // Don't clear this error - user needs to interact
            URL.revokeObjectURL(audioUrl);
            ttsAudio = null;
            processQueue();
            return;
          }
          throw playError;
        }

      } catch (error) {
        console.error("[TTS] Synthesis error:", error.message || error);
        setTTSStatus("Voice error", "error");
        // Clear error status after 5 seconds
        setTimeout(() => {
          if (ttsStatus.textContent === "Voice error") {
            ttsStatus.textContent = "";
            ttsStatus.className = "tts-status";
          }
        }, 5000);
        processQueue();  // Continue with next item
      }
    }

    // Stop current speech
    function stopSpeaking() {
      ttsQueue = [];
      if (ttsAudio) {
        ttsAudio.pause();
        ttsAudio = null;
      }
      ttsSpeaking = false;
      setTTSStatus("");
    }

    // Event: Voice selection change
    ttsVoiceSelect.addEventListener("change", () => {
      ttsSelectedVoice = ttsVoiceSelect.value;
      localStorage.setItem("tts_voice", ttsSelectedVoice);
      console.log("[TTS] Voice changed to:", ttsSelectedVoice);
    });

    // Event: Mute button click
    ttsMuteBtn.addEventListener("click", () => {
      ttsMuted = !ttsMuted;
      localStorage.setItem("tts_muted", ttsMuted);
      updateMuteButtonUI();

      if (ttsMuted) {
        stopSpeaking();
      }

      console.log("[TTS] Muted:", ttsMuted);
    });

    // Initialize TTS UI (voices are loaded in the window.load handler)
    updateMuteButtonUI();

    // Enable audio after any user interaction (to bypass autoplay restrictions)
    let audioEnabled = false;
    let pendingGreeting = null;  // Store greeting to play after user interaction

    async function enableAudioAndPlayGreeting() {
      if (!audioEnabled) {
        audioEnabled = true;
        // Clear the "Click to enable voice" message if present
        if (ttsStatus.textContent === "Click to enable voice") {
          ttsStatus.textContent = "";
          ttsStatus.className = "tts-status";
        }
        console.log("[TTS] Audio enabled after user interaction");

        // Play the pending greeting if we have one
        if (pendingGreeting && !ttsMuted) {
          console.log("[TTS] Playing queued greeting");
          await speakText(pendingGreeting);
          pendingGreeting = null;
        }
      }
    }
    document.addEventListener("click", enableAudioAndPlayGreeting, { once: true });
    document.addEventListener("keydown", enableAudioAndPlayGreeting, { once: true });

    // =====================================================
    // Integrate TTS with chat - speak bot responses
    // =====================================================

    // Override addMessage to trigger TTS for assistant messages
    const originalAddMessage = addMessage;
    addMessage = function(role, text) {
      originalAddMessage(role, text);

      // Speak assistant messages
      if (role === "assistant" && text) {
        speakText(text);
      }
    };
  </script>
</body>
</html>
