<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Order Bot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
    }
    .app-header {
      background: #1976d2;
      color: white;
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 18px;
      font-weight: 600;
    }
    .app-header span.sub {
      font-size: 13px;
      font-weight: 400;
      opacity: 0.9;
    }
    .chat-container {
      max-width: 900px;
      margin: 20px auto;
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      height: calc(100vh - 80px);
      overflow: hidden;
    }
    .chat-header {
      padding: 10px 16px;
      text-align: center;
      font-size: 13px;
      color: #666;
      border-bottom: 1px solid #eee;
    }
    .chat-messages {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      background: #fafafa;
    }
    .msg-row {
      display: flex;
      margin-bottom: 10px;
    }
    .msg-row.user {
      justify-content: flex-end;
    }
    .msg-row.assistant {
      justify-content: flex-start;
    }
    .msg-bubble {
      max-width: 70%;
      padding: 10px 14px;
      border-radius: 16px;
      font-size: 14px;
      line-height: 1.4;
    }
    .msg-row.user .msg-bubble {
      background: #1976d2;
      color: white;
      border-bottom-right-radius: 4px;
    }
    .msg-row.assistant .msg-bubble {
      background: white;
      border: 1px solid #e0e0e0;
      border-bottom-left-radius: 4px;
    }
    .chat-footer {
      border-top: 1px solid #eee;
      padding: 10px;
      display: flex;
      gap: 8px;
      background: #fff;
    }
    .chat-footer input[type="text"] {
      flex: 1;
      border-radius: 20px;
      border: 1px solid #ccc;
      padding: 8px 12px;
      font-size: 14px;
      outline: none;
    }
    .chat-footer button {
      border-radius: 20px;
      border: none;
      background: #1976d2;
      color: white;
      padding: 0 18px;
      font-size: 14px;
      cursor: pointer;
    }
    .chat-footer button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    /* Microphone button styles */
    .mic-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      background: #f0f0f0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: all 0.2s;
    }
    .mic-btn:hover {
      background: #e0e0e0;
    }
    .mic-btn.listening {
      background: #ef5350;
      animation: pulse 1.5s infinite;
    }
    .mic-btn.listening:hover {
      background: #e53935;
    }
    .mic-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .mic-status {
      font-size: 11px;
      color: #666;
      text-align: center;
      min-height: 16px;
      padding: 2px 0;
    }
    .mic-status.error {
      color: #c62828;
    }
    .mic-status.listening {
      color: #2e7d32;
    }
    .status-bar {
      font-size: 12px;
      color: #777;
      padding: 4px 16px 8px;
    }
    /* Caller ID simulation */
    .caller-id-panel {
      padding: 10px 16px;
      background: #fff3cd;
      border-bottom: 1px solid #ffc107;
      font-size: 13px;
    }
    .caller-id-panel summary {
      cursor: pointer;
      color: #856404;
      font-weight: 500;
    }
    .caller-id-panel summary:hover {
      text-decoration: underline;
    }
    .caller-id-content {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .caller-id-content input {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 13px;
    }
    .caller-id-content button {
      padding: 6px 12px;
      background: #ffc107;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
    }
    .caller-id-content button:hover {
      background: #e0a800;
    }
    .returning-customer-badge {
      background: #28a745;
      color: white;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 11px;
      margin-left: 8px;
    }
    /* Typing indicator styles */
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 10px 14px;
    }
    .typing-indicator .dot {
      width: 8px;
      height: 8px;
      background: #999;
      border-radius: 50%;
      animation: typing-bounce 1.4s infinite ease-in-out both;
    }
    .typing-indicator .dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-indicator .dot:nth-child(2) { animation-delay: -0.16s; }
    .typing-indicator .dot:nth-child(3) { animation-delay: 0s; }
    @keyframes typing-bounce {
      0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
      40% { transform: scale(1); opacity: 1; }
    }
    /* TTS Controls */
    .tts-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 16px;
      background: #f0f7ff;
      border-bottom: 1px solid #d0e3f7;
      font-size: 13px;
    }
    .tts-controls label {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #1565c0;
    }
    .tts-controls select {
      padding: 4px 8px;
      border: 1px solid #90caf9;
      border-radius: 4px;
      font-size: 12px;
      background: white;
    }
    .tts-mute-btn {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border: 1px solid #90caf9;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 12px;
      color: #1565c0;
      transition: all 0.2s;
    }
    .tts-mute-btn:hover {
      background: #e3f2fd;
    }
    .tts-mute-btn.muted {
      background: #ffebee;
      border-color: #ef9a9a;
      color: #c62828;
    }
    .tts-mute-btn .icon {
      font-size: 16px;
    }
    .tts-status {
      margin-left: auto;
      font-size: 11px;
      color: #666;
    }
    .tts-status.speaking {
      color: #2e7d32;
    }
    .tts-status.error {
      color: #c62828;
    }

    /* =====================================================
       Order Panel Styles - Desktop Side Panel + Mobile Bottom Sheet
       ===================================================== */

    /* Main layout wrapper */
    .main-layout {
      display: flex;
      max-width: 1200px;
      margin: 20px auto;
      gap: 20px;
      padding: 0 20px;
      height: calc(100vh - 80px);
    }

    /* Override chat-container for new layout */
    .main-layout .chat-container {
      flex: 1;
      max-width: none;
      margin: 0;
    }

    /* Order Panel - Desktop (Side Panel) */
    .order-panel {
      width: 320px;
      min-width: 280px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .order-panel-header {
      padding: 14px 16px;
      background: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
      font-weight: 600;
      font-size: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .order-panel-header .icon {
      font-size: 18px;
    }

    .order-panel-body {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .order-panel-footer {
      padding: 16px;
      border-top: 1px solid #e0e0e0;
      background: #f8f9fa;
    }

    /* Order Items */
    .order-item {
      padding: 12px 0;
      border-bottom: 1px solid #f0f0f0;
    }

    .order-item:last-child {
      border-bottom: none;
    }

    .order-item-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 4px;
    }

    .order-item-name {
      font-weight: 500;
      font-size: 14px;
      color: #333;
    }

    .order-item-price {
      font-weight: 500;
      font-size: 14px;
      color: #333;
      white-space: nowrap;
    }

    .order-item-details {
      font-size: 12px;
      color: #666;
      line-height: 1.4;
      margin-top: 4px;
    }

    .order-item-detail {
      display: block;
    }

    .order-item-note {
      margin-top: 4px;
      font-style: italic;
      color: #888;
    }

    .order-item-modifiers {
      margin-top: 4px;
      padding-left: 12px;
    }

    .order-item-modifier {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #666;
      padding: 2px 0;
    }

    .order-item-modifier-name {
      display: flex;
      align-items: center;
    }

    .order-item-modifier-name::before {
      content: "+";
      margin-right: 6px;
      color: #888;
    }

    .order-item-modifier-price {
      color: #888;
      white-space: nowrap;
    }

    /* Order Totals */
    .order-totals {
      font-size: 14px;
    }

    .order-total-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
    }

    .order-total-row.subtotal {
      padding-top: 8px;
      border-top: 1px solid #e0e0e0;
    }

    .order-total-row.total {
      font-weight: 600;
      font-size: 16px;
      padding-top: 8px;
      margin-top: 4px;
      border-top: 2px solid #333;
    }

    .order-total-label {
      color: #666;
    }

    .order-total-row.total .order-total-label {
      color: #333;
    }

    /* Order Type Badge */
    .order-type-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: #e3f2fd;
      color: #1565c0;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 12px;
    }

    .order-type-badge.delivery {
      background: #fff3e0;
      color: #e65100;
    }

    .order-type-badge .icon {
      font-size: 16px;
    }

    /* Empty State */
    .order-empty {
      text-align: center;
      padding: 40px 20px;
      color: #999;
    }

    .order-empty .icon {
      font-size: 48px;
      margin-bottom: 12px;
      opacity: 0.5;
    }

    .order-empty p {
      margin: 0;
      font-size: 14px;
    }

    /* Order Status */
    .order-status {
      text-align: center;
      padding: 12px;
      margin-top: 12px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
    }

    .order-status.confirmed {
      background: #e8f5e9;
      color: #2e7d32;
    }

    .order-status.pending {
      background: #fff8e1;
      color: #f57f17;
    }

    /* Customer Info */
    .order-customer {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #e0e0e0;
      font-size: 13px;
      color: #666;
    }

    .order-customer-row {
      display: flex;
      gap: 8px;
      margin-bottom: 4px;
    }

    .order-customer-row .icon {
      width: 16px;
      text-align: center;
    }

    /* Mobile Bottom Sheet */
    .order-panel-mobile {
      display: none;
    }

    /* Mobile Collapsed Bar */
    .order-panel-collapsed {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      border-top: 1px solid #e0e0e0;
      padding: 12px 16px;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      z-index: 100;
      cursor: pointer;
    }

    .order-panel-collapsed-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .order-panel-collapsed-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .order-panel-collapsed-icon {
      font-size: 20px;
    }

    .order-panel-collapsed-text {
      font-weight: 500;
      font-size: 14px;
    }

    .order-panel-collapsed-total {
      font-weight: 600;
      font-size: 16px;
      color: #1976d2;
    }

    .order-panel-collapsed-chevron {
      font-size: 18px;
      color: #999;
    }

    /* Mobile Expanded Panel (Bottom Sheet) */
    .order-panel-expanded {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      max-height: 70vh;
      background: white;
      border-top-left-radius: 16px;
      border-top-right-radius: 16px;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.15);
      z-index: 101;
      flex-direction: column;
      overflow: hidden;
    }

    .order-panel-expanded.active {
      display: flex;
    }

    .order-panel-expanded-header {
      padding: 16px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .order-panel-expanded-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .order-panel-expanded-close {
      font-size: 20px;
      color: #666;
    }

    .order-panel-expanded-body {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .order-panel-expanded-footer {
      padding: 16px;
      border-top: 1px solid #e0e0e0;
      background: #f8f9fa;
    }

    /* Mobile overlay */
    .order-panel-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.4);
      z-index: 100;
    }

    .order-panel-overlay.active {
      display: block;
    }

    /* Responsive: Mobile layout */
    @media (max-width: 900px) {
      .main-layout {
        flex-direction: column;
        padding: 0;
        margin: 0;
        height: calc(100vh - 56px);
        gap: 0;
      }

      .main-layout .chat-container {
        border-radius: 0;
        height: calc(100vh - 56px - 60px); /* Account for collapsed order bar */
      }

      /* Hide desktop panel */
      .order-panel {
        display: none;
      }

      /* Show mobile elements */
      .order-panel-mobile {
        display: block;
      }

      .order-panel-collapsed {
        display: block;
      }
    }
  </style>
</head>
<body>
  <div class="app-header">
    <div>Order Bot</div>
    <span class="sub">Demo web chat ¬∑ Local FastAPI backend</span>
  </div>

  <div class="main-layout">
    <div class="chat-container">
    <!-- Caller ID Simulation Panel (Dev/Demo Mode) -->
    <details class="caller-id-panel" id="caller-id-panel">
      <summary>Simulate Incoming Call (Dev Mode)</summary>
      <div class="caller-id-content">
        <label for="store-select" style="white-space: nowrap;">Store:</label>
        <select id="store-select" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
          <!-- Populated dynamically from localStorage -->
        </select>
      </div>
      <div class="caller-id-content" style="margin-top: 8px;">
        <input
          type="tel"
          id="caller-id-input"
          placeholder="Enter phone number (e.g., 555-123-4567)"
        />
        <button type="button" id="start-with-caller-id">Start Call</button>
      </div>
      <div style="margin-top: 6px; color: #666; font-size: 12px;">
        Select a store and optionally enter a phone number. URL params: <code>?store=store_eb_001&caller_id=555-123-4567</code>
      </div>
    </details>

    <!-- TTS Voice Controls -->
    <div class="tts-controls" id="tts-controls">
      <label>
        <span class="icon">üîä</span>
        Voice:
        <select id="tts-voice-select">
          <option value="">Loading voices...</option>
        </select>
      </label>
      <button type="button" class="tts-mute-btn" id="tts-mute-btn" title="Toggle voice on/off">
        <span class="icon">üîä</span>
        <span class="label">Voice On</span>
      </button>
      <span class="tts-status" id="tts-status"></span>
    </div>

    <div class="chat-header" id="chat-header">
      Connecting...
    </div>
    <div class="chat-messages" id="chat-messages"></div>
    <div class="status-bar" id="status-bar">Disconnected</div>
    <div class="mic-status" id="mic-status"></div>
    <form class="chat-footer" id="chat-form">
      <input
        type="text"
        id="chat-input"
        autocomplete="off"
        placeholder="Type your message..."
      />
      <button type="button" class="mic-btn" id="mic-btn" title="Voice input (click to speak)">üé§</button>
      <button type="submit">Send</button>
    </form>
    </div>

    <!-- Order Panel - Desktop (Side Panel) -->
    <div class="order-panel" id="order-panel">
      <div class="order-panel-header">
        <span class="icon">üõí</span>
        Your Order
      </div>
      <div class="order-panel-body" id="order-panel-body">
        <div class="order-empty" id="order-empty">
          <div class="icon">üõí</div>
          <p>Your cart is empty</p>
          <p style="font-size: 12px; margin-top: 8px;">Items will appear here as you order</p>
        </div>
        <div id="order-items-container" style="display: none;">
          <!-- Order type badge -->
          <div class="order-type-badge" id="order-type-badge" style="display: none;">
            <span class="icon">üè™</span>
            <span id="order-type-text">Pickup</span>
          </div>
          <!-- Order items list -->
          <div id="order-items-list"></div>
        </div>
      </div>
      <div class="order-panel-footer" id="order-panel-footer" style="display: none;">
        <div class="order-totals">
          <div class="order-total-row subtotal">
            <span class="order-total-label">Subtotal</span>
            <span id="order-subtotal">$0.00</span>
          </div>
          <div class="order-total-row" id="order-city-tax-row" style="display: none;">
            <span class="order-total-label">City Tax</span>
            <span id="order-city-tax">$0.00</span>
          </div>
          <div class="order-total-row" id="order-state-tax-row" style="display: none;">
            <span class="order-total-label">State Tax</span>
            <span id="order-state-tax">$0.00</span>
          </div>
          <div class="order-total-row" id="order-delivery-row" style="display: none;">
            <span class="order-total-label">Delivery Fee</span>
            <span id="order-delivery-fee">$0.00</span>
          </div>
          <div class="order-total-row total">
            <span class="order-total-label">Total</span>
            <span id="order-total">$0.00</span>
          </div>
        </div>
        <!-- Order status -->
        <div class="order-status" id="order-status-badge" style="display: none;">
          Order Confirmed!
        </div>
        <!-- Customer info (when available) -->
        <div class="order-customer" id="order-customer" style="display: none;">
          <div class="order-customer-row" id="customer-name-row">
            <span class="icon">üë§</span>
            <span id="customer-name"></span>
          </div>
          <div class="order-customer-row" id="customer-phone-row" style="display: none;">
            <span class="icon">üìû</span>
            <span id="customer-phone"></span>
          </div>
          <div class="order-customer-row" id="customer-address-row" style="display: none;">
            <span class="icon">üìç</span>
            <span id="customer-address"></span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Mobile Order Panel -->
  <div class="order-panel-mobile" id="order-panel-mobile">
    <!-- Overlay for when expanded -->
    <div class="order-panel-overlay" id="order-panel-overlay"></div>

    <!-- Collapsed bar (always visible on mobile) -->
    <div class="order-panel-collapsed" id="order-panel-collapsed">
      <div class="order-panel-collapsed-content">
        <div class="order-panel-collapsed-left">
          <span class="order-panel-collapsed-icon">üõí</span>
          <span class="order-panel-collapsed-text" id="mobile-cart-summary">Cart empty</span>
        </div>
        <div class="order-panel-collapsed-total" id="mobile-cart-total">$0.00</div>
        <span class="order-panel-collapsed-chevron">‚ñ≤</span>
      </div>
    </div>

    <!-- Expanded bottom sheet -->
    <div class="order-panel-expanded" id="order-panel-expanded">
      <div class="order-panel-expanded-header" id="order-panel-expanded-header">
        <h3><span class="icon">üõí</span> Your Order</h3>
        <span class="order-panel-expanded-close">‚úï</span>
      </div>
      <div class="order-panel-expanded-body" id="order-panel-expanded-body">
        <!-- Content cloned from desktop panel -->
      </div>
      <div class="order-panel-expanded-footer" id="order-panel-expanded-footer">
        <!-- Footer content cloned from desktop panel -->
      </div>
    </div>
  </div>

  <script>
    const messagesEl = document.getElementById("chat-messages");
    const headerEl = document.getElementById("chat-header");
    const statusEl = document.getElementById("status-bar");
    const formEl = document.getElementById("chat-form");
    const inputEl = document.getElementById("chat-input");
    const callerIdPanel = document.getElementById("caller-id-panel");
    const callerIdInput = document.getElementById("caller-id-input");
    const storeSelect = document.getElementById("store-select");
    const startWithCallerIdBtn = document.getElementById("start-with-caller-id");

    // Store name mapping (built dynamically)
    let STORE_NAMES = {};

    // Enable streaming responses for faster feedback (set to false to use original behavior)
    const USE_STREAMING = true;

    // Company info (loaded from API)
    let companyInfo = {
      name: "Sammy's Subs",
      bot_persona_name: "Sammy",
      primary_item_type: "Sandwich"
    };

    // Load company info from API
    async function loadCompanyInfo() {
      try {
        const response = await fetch("/company");
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        companyInfo = await response.json();
        console.log("[Company] Loaded company info:", companyInfo.name);

        // Update page title and header with dynamic item type (Pizza Bot, Sandwich Bot, etc.)
        const itemType = companyInfo.primary_item_type || "Sandwich";
        document.title = `${companyInfo.bot_persona_name} the ${itemType} Bot`;
        document.querySelector(".app-header > div").textContent =
          `${companyInfo.bot_persona_name} the ${itemType} Bot`;

        return companyInfo;
      } catch (error) {
        console.error("[Company] Failed to load company info:", error);
        // Keep defaults
        return companyInfo;
      }
    }

    // Load stores from API and populate dropdown
    async function loadStoresAndPopulateDropdown() {
      let stores = [];

      try {
        // Fetch available (open, non-deleted) stores from API
        const response = await fetch("/stores");
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        stores = await response.json();
        console.log("[Store Loader] Loaded stores from API:", stores.length);
      } catch (error) {
        console.error("[Store Loader] Failed to load stores from API:", error);
        // No fallback - empty stores is better than wrong stores for multi-tenant
        stores = [];
      }

      // Map API response to available stores (already filtered by API)
      const availableStores = stores.map(s => ({
        id: s.store_id,
        name: s.name
      }));

      console.log("[Store Loader] Available stores:", availableStores.length);

      // Build STORE_NAMES mapping
      STORE_NAMES = {};
      availableStores.forEach(store => {
        // Extract short name (e.g., "East Brunswick" from "Sammy's Subs - East Brunswick")
        const shortName = store.name.includes(" - ")
          ? store.name.split(" - ").pop()
          : store.name;
        STORE_NAMES[store.id] = shortName;
      });

      // Populate dropdown
      storeSelect.innerHTML = "";
      if (availableStores.length === 0) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No stores available";
        storeSelect.appendChild(opt);
      } else {
        availableStores.forEach(store => {
          const opt = document.createElement("option");
          opt.value = store.id;
          opt.textContent = STORE_NAMES[store.id];
          storeSelect.appendChild(opt);
        });
      }

      return availableStores;
    }

    let sessionId = null;
    let connected = false;
    let currentCallerId = null;
    let currentStoreId = null;

    let typingIndicatorEl = null;

    // Analytics tracking
    let sessionStartTime = null;
    let messageCount = 0;
    let orderState = { status: "pending", items: [], total_price: 0 };
    let lastBotMessage = null;
    let lastUserMessage = null;
    let orderConfirmed = false;
    let conversationHistory = [];  // Track full conversation for analytics

    function addMessage(role, text) {
      const row = document.createElement("div");
      row.className = "msg-row " + role;

      const bubble = document.createElement("div");
      bubble.className = "msg-bubble";
      bubble.textContent = text;

      row.appendChild(bubble);
      messagesEl.appendChild(row);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function showTypingIndicator() {
      if (typingIndicatorEl) return; // Already showing

      const row = document.createElement("div");
      row.className = "msg-row assistant";

      const bubble = document.createElement("div");
      bubble.className = "msg-bubble typing-indicator";
      bubble.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';

      row.appendChild(bubble);
      messagesEl.appendChild(row);
      messagesEl.scrollTop = messagesEl.scrollHeight;

      typingIndicatorEl = row;
    }

    function hideTypingIndicator() {
      if (typingIndicatorEl) {
        typingIndicatorEl.remove();
        typingIndicatorEl = null;
      }
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    async function startSession(callerId = null, storeId = null) {
      try {
        setStatus("Starting session...");

        // Build URL with optional parameters
        let url = "/chat/start";
        const params = new URLSearchParams();
        if (callerId) {
          params.append("caller_id", callerId);
          currentCallerId = callerId;
        }
        if (storeId) {
          params.append("store_id", storeId);
          currentStoreId = storeId;
        }
        if (params.toString()) {
          url += "?" + params.toString();
        }

        const resp = await fetch(url, {
          method: "POST",
        });
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        const data = await resp.json();
        sessionId = data.session_id;
        connected = true;
        sessionStartTime = Date.now();

        // Update header with store and caller ID info
        let headerText = "Session: " + sessionId.substring(0, 8);
        if (storeId && STORE_NAMES[storeId]) {
          headerText += ` | ${STORE_NAMES[storeId]}`;
        }
        if (callerId) {
          headerText += ` | Caller: ${callerId}`;
        }
        if (data.returning_customer && data.returning_customer.name) {
          headerText += ` | ${data.returning_customer.name}`;
          // Add returning customer badge
          headerEl.innerHTML = headerText + '<span class="returning-customer-badge">Returning Customer</span>';
        } else {
          headerEl.textContent = headerText;
        }

        setStatus("Connected");

        // Collapse the caller ID panel after starting
        callerIdPanel.removeAttribute("open");

        // üîπ Show Sammy's initial greeting from backend
        if (data.message) {
          addMessage("assistant", data.message);
          lastBotMessage = data.message;
          messageCount++;
          conversationHistory.push({ role: "assistant", content: data.message });
        }

        // Log returning customer info if present
        if (data.returning_customer) {
          console.log("Returning customer:", data.returning_customer);
        }
      } catch (err) {
        console.error("Error starting session:", err);
        headerEl.textContent = "Error starting session";
        setStatus("Failed to connect");
      }
    }

    async function sendMessage(text) {
      if (!sessionId) {
        console.warn("No sessionId yet");
        return;
      }
      addMessage("user", text);
      lastUserMessage = text;
      messageCount++;
      conversationHistory.push({ role: "user", content: text });
      setStatus("Sending...");
      showTypingIndicator();

      if (USE_STREAMING) {
        await sendMessageStreaming(text);
      } else {
        await sendMessageNonStreaming(text);
      }
    }

    async function sendMessageNonStreaming(text) {
      try {
        const resp = await fetch("/chat/message", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId, message: text }),
        });
        hideTypingIndicator();
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        const data = await resp.json();
        if (data.reply) {
          addMessage("assistant", data.reply);
          lastBotMessage = data.reply;
          messageCount++;
          conversationHistory.push({ role: "assistant", content: data.reply });
        }
        // Track order state for analytics
        if (data.order_state) {
          orderState = data.order_state;
          if (orderState.status === "confirmed") {
            orderConfirmed = true;
          }
        }
        setStatus("Connected");
      } catch (err) {
        hideTypingIndicator();
        console.error("Error sending message:", err);
        addMessage("assistant", "Oops, something went wrong talking to the backend.");
        setStatus("Backend error");
      }
    }

    async function sendMessageStreaming(text) {
      let streamingMessageEl = null;
      let fullReply = "";

      try {
        const resp = await fetch("/chat/message/stream", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId, message: text }),
        });

        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }

        hideTypingIndicator();
        setStatus("Receiving...");

        // Create a message element for streaming content
        streamingMessageEl = document.createElement("div");
        streamingMessageEl.className = "message assistant";
        streamingMessageEl.textContent = "";
        messagesEl.appendChild(streamingMessageEl);
        messagesEl.scrollTop = messagesEl.scrollHeight;

        const reader = resp.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value);
          const lines = chunk.split("\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const jsonStr = line.slice(6);
              if (!jsonStr) continue;

              try {
                const event = JSON.parse(jsonStr);

                if (event.token) {
                  // Streaming token - but we're getting JSON, so we need to parse the reply
                  // The tokens are parts of the JSON response, not the reply text directly
                  // We'll accumulate and parse at the end
                }

                if (event.done) {
                  // Final event with complete data
                  fullReply = event.reply || "";
                  streamingMessageEl.textContent = fullReply;

                  if (fullReply) {
                    lastBotMessage = fullReply;
                    messageCount++;
                    conversationHistory.push({ role: "assistant", content: fullReply });

                    // Trigger TTS for the assistant response
                    if (typeof speakText === "function") {
                      speakText(fullReply);
                    }
                  }

                  // Track order state for analytics
                  if (event.order_state) {
                    orderState = event.order_state;
                    if (orderState.status === "confirmed") {
                      orderConfirmed = true;
                    }
                  }
                  setStatus("Connected");
                }

                if (event.error) {
                  streamingMessageEl.textContent = event.error;
                  setStatus("Error");
                }
              } catch (e) {
                console.error("Failed to parse SSE event:", e);
              }
            }
          }
        }
      } catch (err) {
        hideTypingIndicator();
        console.error("Error sending streaming message:", err);
        if (streamingMessageEl) {
          streamingMessageEl.textContent = "Oops, something went wrong talking to the backend.";
        } else {
          addMessage("assistant", "Oops, something went wrong talking to the backend.");
        }
        setStatus("Backend error");
      }
    }

    formEl.addEventListener("submit", (e) => {
      e.preventDefault();
      const text = inputEl.value.trim();
      if (!text) return;
      inputEl.value = "";
      sendMessage(text);
    });

    // Handle "Start Call" button click with caller ID and store
    startWithCallerIdBtn.addEventListener("click", () => {
      const callerId = callerIdInput.value.trim();
      const storeId = storeSelect.value;

      // Reset session state if we already had a session
      if (sessionId) {
        sessionId = null;
        connected = false;
        messagesEl.innerHTML = "";
        messageCount = 0;
        orderState = { status: "pending", items: [], total_price: 0 };
        lastBotMessage = null;
        lastUserMessage = null;
        orderConfirmed = false;
        conversationHistory = [];
        abandonAnalyticsSent = false;
      }
      startSession(callerId || null, storeId);
    });

    // Start session on page load - check URL params first
    window.addEventListener("load", async () => {
      // Load company info first (updates page title/header)
      await loadCompanyInfo();

      // Load TTS voices (so greeting can be spoken)
      await loadTTSVoices();

      // Load stores from API and populate dropdown
      const availableStores = await loadStoresAndPopulateDropdown();

      const urlParams = new URLSearchParams(window.location.search);
      const storeIdParam = urlParams.get("store") || urlParams.get("store_id");
      const callerIdParam = urlParams.get("caller_id");

      // Set dropdown value if store param provided and store is available
      if (storeIdParam && STORE_NAMES[storeIdParam]) {
        storeSelect.value = storeIdParam;
      }

      // Set caller ID input if provided
      if (callerIdParam) {
        callerIdInput.value = callerIdParam;
      }

      // Start session with params (store defaults to first option if not specified)
      const storeId = storeIdParam && STORE_NAMES[storeIdParam] ? storeIdParam : storeSelect.value;
      if (storeId) {
        startSession(callerIdParam || null, storeId);
      } else {
        headerEl.textContent = "No stores available";
        setStatus("Please add stores in Store Management");
      }
    });

    // Track abandoned sessions (simulates "hang up")
    let abandonAnalyticsSent = false;  // Prevent duplicate sends

    function sendAbandonAnalytics(reason) {
      // Don't send if already sent, no session, or order was confirmed
      if (abandonAnalyticsSent || !sessionId || orderConfirmed) {
        return;
      }

      abandonAnalyticsSent = true;  // Mark as sent to prevent duplicates

      const items = orderState.items || [];
      const sessionDuration = sessionStartTime
        ? Math.floor((Date.now() - sessionStartTime) / 1000)
        : null;

      const payload = {
        session_id: sessionId,
        message_count: messageCount,
        had_items_in_cart: items.length > 0,
        item_count: items.length,
        cart_total: orderState.total_price || 0,
        order_status: orderState.status || "pending",
        last_bot_message: lastBotMessage,
        last_user_message: lastUserMessage,
        reason: reason,
        session_duration_seconds: sessionDuration,
        conversation_history: conversationHistory,  // Include full conversation
        store_id: currentStoreId,  // Include store for analytics
      };

      // Use sendBeacon for reliability during page unload
      // It's fire-and-forget and works even when the page is closing
      const blob = new Blob([JSON.stringify(payload)], { type: "application/json" });
      navigator.sendBeacon("/chat/abandon", blob);

      console.log("Abandon analytics sent:", reason);
    }

    // Detect page unload (refresh, close, or navigation)
    // Use only beforeunload as it's most reliable and fires first
    window.addEventListener("beforeunload", (event) => {
      // Detect if this is a refresh vs close/navigation
      // Note: We can't perfectly distinguish close vs navigation in beforeunload
      sendAbandonAnalytics("browser_close");
    });

    // =====================================================
    // TTS (Text-to-Speech) Functionality
    // =====================================================

    const ttsVoiceSelect = document.getElementById("tts-voice-select");
    const ttsMuteBtn = document.getElementById("tts-mute-btn");
    const ttsStatus = document.getElementById("tts-status");

    // TTS State
    let ttsVoices = [];
    let ttsMuted = localStorage.getItem("tts_muted") === "true";
    let ttsSelectedVoice = localStorage.getItem("tts_voice") || null;
    let ttsAudio = null;  // Current audio element
    let ttsQueue = [];    // Queue of texts to speak
    let ttsSpeaking = false;
    let ttsReady = false; // Flag to track if TTS is initialized

    // Initialize mute button state
    function updateMuteButtonUI() {
      if (ttsMuted) {
        ttsMuteBtn.classList.add("muted");
        ttsMuteBtn.querySelector(".icon").textContent = "üîá";
        ttsMuteBtn.querySelector(".label").textContent = "Voice Off";
      } else {
        ttsMuteBtn.classList.remove("muted");
        ttsMuteBtn.querySelector(".icon").textContent = "üîä";
        ttsMuteBtn.querySelector(".label").textContent = "Voice On";
      }
    }

    // Load available voices from API
    async function loadTTSVoices() {
      try {
        const response = await fetch("/tts/voices");
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        ttsVoices = data.voices || [];

        // Populate voice dropdown
        ttsVoiceSelect.innerHTML = "";
        ttsVoices.forEach(voice => {
          const opt = document.createElement("option");
          opt.value = voice.id;
          // Format: "Nova (Female, American) - Friendly and upbeat"
          let label = voice.name;
          if (voice.gender || voice.accent) {
            const details = [voice.gender, voice.accent].filter(Boolean).join(", ");
            label += ` (${details})`;
          }
          if (voice.description) {
            label += ` - ${voice.description}`;
          }
          opt.textContent = label;
          ttsVoiceSelect.appendChild(opt);
        });

        // Restore saved voice selection or use default
        if (ttsSelectedVoice && ttsVoices.some(v => v.id === ttsSelectedVoice)) {
          ttsVoiceSelect.value = ttsSelectedVoice;
        } else if (ttsVoices.length > 0) {
          // Default to "nova" if available, otherwise first voice
          const defaultVoice = ttsVoices.find(v => v.id === "nova") || ttsVoices[0];
          ttsVoiceSelect.value = defaultVoice.id;
          ttsSelectedVoice = defaultVoice.id;
        }

        ttsReady = true;
        console.log(`[TTS] Loaded ${ttsVoices.length} voices from ${data.provider}, selected: ${ttsSelectedVoice}`);
      } catch (error) {
        console.error("[TTS] Failed to load voices:", error);
        ttsVoiceSelect.innerHTML = '<option value="">Voice unavailable</option>';
        setTTSStatus("Voice unavailable", "error");
        ttsReady = false;
      }
    }

    // Set TTS status message
    function setTTSStatus(message, type = "") {
      ttsStatus.textContent = message;
      ttsStatus.className = "tts-status" + (type ? ` ${type}` : "");
      // Auto-clear status after 3 seconds (unless it's an error)
      if (type !== "error" && message) {
        setTimeout(() => {
          if (ttsStatus.textContent === message) {
            ttsStatus.textContent = "";
            ttsStatus.className = "tts-status";
          }
        }, 3000);
      }
    }

    // Synthesize and play text
    async function speakText(text) {
      if (ttsMuted || !text) return;

      // Check if TTS is ready
      if (!ttsReady || !ttsSelectedVoice) {
        console.warn("[TTS] Not ready yet, skipping:", text.substring(0, 50) + "...");
        return;
      }

      // Add to queue
      ttsQueue.push(text);

      // If already speaking, the queue will be processed
      if (ttsSpeaking) return;

      await processQueue();
    }

    async function processQueue() {
      if (ttsQueue.length === 0) {
        ttsSpeaking = false;
        return;
      }

      ttsSpeaking = true;
      const text = ttsQueue.shift();

      try {
        setTTSStatus("Speaking...", "speaking");

        // Stop any currently playing audio
        if (ttsAudio) {
          ttsAudio.pause();
          ttsAudio = null;
        }

        // Call TTS API
        console.log("[TTS] Calling synthesize API with voice:", ttsSelectedVoice);
        const response = await fetch("/tts/synthesize", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            text: text,
            voice: ttsSelectedVoice,
            speed: 1.0
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error("[TTS] API error:", response.status, errorText);
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        // Get audio blob and play it
        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);

        ttsAudio = new Audio(audioUrl);

        // Clean up URL when done
        ttsAudio.onended = () => {
          URL.revokeObjectURL(audioUrl);
          setTTSStatus("");
          processQueue();  // Process next in queue
        };

        ttsAudio.onerror = (e) => {
          console.error("[TTS] Audio playback error:", e);
          URL.revokeObjectURL(audioUrl);
          setTTSStatus("Playback error", "error");
          processQueue();  // Continue with next item
        };

        // Handle mute during playback
        if (ttsMuted) {
          ttsAudio = null;
          setTTSStatus("");
          processQueue();
          return;
        }

        try {
          await ttsAudio.play();
        } catch (playError) {
          // Browser may block autoplay without user interaction
          if (playError.name === 'NotAllowedError') {
            console.warn("[TTS] Autoplay blocked by browser - waiting for user interaction");
            setTTSStatus("Click to enable voice", "error");
            // Don't clear this error - user needs to interact
            URL.revokeObjectURL(audioUrl);
            ttsAudio = null;
            processQueue();
            return;
          }
          throw playError;
        }

      } catch (error) {
        console.error("[TTS] Synthesis error:", error.message || error);
        setTTSStatus("Voice error", "error");
        // Clear error status after 5 seconds
        setTimeout(() => {
          if (ttsStatus.textContent === "Voice error") {
            ttsStatus.textContent = "";
            ttsStatus.className = "tts-status";
          }
        }, 5000);
        processQueue();  // Continue with next item
      }
    }

    // Stop current speech
    function stopSpeaking() {
      ttsQueue = [];
      if (ttsAudio) {
        ttsAudio.pause();
        ttsAudio = null;
      }
      ttsSpeaking = false;
      setTTSStatus("");
    }

    // Event: Voice selection change
    ttsVoiceSelect.addEventListener("change", () => {
      ttsSelectedVoice = ttsVoiceSelect.value;
      localStorage.setItem("tts_voice", ttsSelectedVoice);
      console.log("[TTS] Voice changed to:", ttsSelectedVoice);
    });

    // Event: Mute button click
    ttsMuteBtn.addEventListener("click", () => {
      ttsMuted = !ttsMuted;
      localStorage.setItem("tts_muted", ttsMuted);
      updateMuteButtonUI();

      if (ttsMuted) {
        stopSpeaking();
      }

      console.log("[TTS] Muted:", ttsMuted);
    });

    // Initialize TTS UI (voices are loaded in the window.load handler)
    updateMuteButtonUI();

    // Enable audio after any user interaction (to bypass autoplay restrictions)
    let audioEnabled = false;
    let pendingGreeting = null;  // Store greeting to play after user interaction

    async function enableAudioAndPlayGreeting() {
      if (!audioEnabled) {
        audioEnabled = true;
        // Clear the "Click to enable voice" message if present
        if (ttsStatus.textContent === "Click to enable voice") {
          ttsStatus.textContent = "";
          ttsStatus.className = "tts-status";
        }
        console.log("[TTS] Audio enabled after user interaction");

        // Play the pending greeting if we have one
        if (pendingGreeting && !ttsMuted) {
          console.log("[TTS] Playing queued greeting");
          await speakText(pendingGreeting);
          pendingGreeting = null;
        }
      }
    }
    document.addEventListener("click", enableAudioAndPlayGreeting, { once: true });
    document.addEventListener("keydown", enableAudioAndPlayGreeting, { once: true });

    // =====================================================
    // Integrate TTS with chat - speak bot responses
    // =====================================================

    // Override addMessage to trigger TTS for assistant messages
    const originalAddMessage = addMessage;
    addMessage = function(role, text) {
      originalAddMessage(role, text);

      // Speak assistant messages
      if (role === "assistant" && text) {
        speakText(text);
      }
    };

    // =====================================================
    // Speech Recognition (Voice Input) Functionality
    // =====================================================

    const micBtn = document.getElementById("mic-btn");
    const micStatus = document.getElementById("mic-status");

    // Check for browser support
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isListening = false;

    function setMicStatus(message, type = "") {
      micStatus.textContent = message;
      micStatus.className = "mic-status" + (type ? ` ${type}` : "");
      // Auto-clear non-error messages after 3 seconds
      if (type !== "error" && message) {
        setTimeout(() => {
          if (micStatus.textContent === message) {
            micStatus.textContent = "";
            micStatus.className = "mic-status";
          }
        }, 3000);
      }
    }

    if (!SpeechRecognition) {
      // Browser doesn't support speech recognition
      micBtn.disabled = true;
      micBtn.title = "Speech recognition not supported in this browser";
      setMicStatus("Voice input not supported", "error");
      console.warn("[Speech] SpeechRecognition API not supported");
    } else {
      // Initialize speech recognition
      recognition = new SpeechRecognition();
      recognition.continuous = false;  // Stop after user pauses
      recognition.interimResults = true;  // Show partial results as user speaks
      recognition.lang = "en-US";
      recognition.maxAlternatives = 1;

      recognition.onstart = () => {
        isListening = true;
        micBtn.classList.add("listening");
        micBtn.textContent = "üî¥";
        setMicStatus("Listening... speak now", "listening");
        console.log("[Speech] Recognition started");

        // Stop any TTS playback when user starts speaking
        if (typeof stopSpeaking === "function") {
          stopSpeaking();
        }
      };

      recognition.onresult = (event) => {
        let finalTranscript = "";
        let interimTranscript = "";

        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript;
          } else {
            interimTranscript += transcript;
          }
        }

        // Show interim results in the input field
        if (interimTranscript) {
          inputEl.value = interimTranscript;
          setMicStatus("Listening...", "listening");
        }

        // When we have a final result, put it in the input
        if (finalTranscript) {
          inputEl.value = finalTranscript;
          console.log("[Speech] Final transcript:", finalTranscript);
        }
      };

      recognition.onend = () => {
        isListening = false;
        micBtn.classList.remove("listening");
        micBtn.textContent = "üé§";
        console.log("[Speech] Recognition ended");

        // Auto-send if we have text in the input
        const text = inputEl.value.trim();
        if (text) {
          setMicStatus("Sending...", "");
          // Small delay to let user see what was transcribed
          setTimeout(() => {
            inputEl.value = "";
            sendMessage(text);
            setMicStatus("");
          }, 300);
        } else {
          setMicStatus("No speech detected", "");
        }
      };

      recognition.onerror = (event) => {
        isListening = false;
        micBtn.classList.remove("listening");
        micBtn.textContent = "üé§";
        console.error("[Speech] Recognition error:", event.error);

        let errorMessage = "Voice error";
        switch (event.error) {
          case "no-speech":
            errorMessage = "No speech detected";
            break;
          case "audio-capture":
            errorMessage = "No microphone found";
            break;
          case "not-allowed":
            errorMessage = "Microphone access denied";
            break;
          case "network":
            errorMessage = "Network error";
            break;
          case "aborted":
            errorMessage = ""; // User cancelled, no need to show error
            break;
        }

        if (errorMessage) {
          setMicStatus(errorMessage, "error");
        }
      };

      // Mic button click handler
      micBtn.addEventListener("click", () => {
        if (!connected || !sessionId) {
          setMicStatus("Start a session first", "error");
          return;
        }

        if (isListening) {
          // Stop listening
          recognition.stop();
          setMicStatus("Stopped", "");
        } else {
          // Start listening
          try {
            inputEl.value = "";  // Clear any existing text
            recognition.start();
          } catch (err) {
            console.error("[Speech] Failed to start recognition:", err);
            setMicStatus("Failed to start voice input", "error");
          }
        }
      });

      console.log("[Speech] Voice recognition initialized");
    }

    // =====================================================
    // Order Panel - Render and Mobile Interactions
    // =====================================================

    // Order panel DOM elements
    const orderPanelBody = document.getElementById("order-panel-body");
    const orderEmpty = document.getElementById("order-empty");
    const orderItemsContainer = document.getElementById("order-items-container");
    const orderItemsList = document.getElementById("order-items-list");
    const orderTypeBadge = document.getElementById("order-type-badge");
    const orderTypeText = document.getElementById("order-type-text");
    const orderPanelFooter = document.getElementById("order-panel-footer");
    const orderSubtotal = document.getElementById("order-subtotal");
    const orderCityTax = document.getElementById("order-city-tax");
    const orderCityTaxRow = document.getElementById("order-city-tax-row");
    const orderStateTax = document.getElementById("order-state-tax");
    const orderStateTaxRow = document.getElementById("order-state-tax-row");
    const orderDeliveryFee = document.getElementById("order-delivery-fee");
    const orderDeliveryRow = document.getElementById("order-delivery-row");
    const orderTotalEl = document.getElementById("order-total");
    const orderStatusBadge = document.getElementById("order-status-badge");
    const orderCustomer = document.getElementById("order-customer");
    const customerNameEl = document.getElementById("customer-name");
    const customerPhoneEl = document.getElementById("customer-phone");
    const customerPhoneRow = document.getElementById("customer-phone-row");
    const customerAddressEl = document.getElementById("customer-address");
    const customerAddressRow = document.getElementById("customer-address-row");

    // Mobile elements
    const orderPanelCollapsed = document.getElementById("order-panel-collapsed");
    const orderPanelExpanded = document.getElementById("order-panel-expanded");
    const orderPanelOverlay = document.getElementById("order-panel-overlay");
    const orderPanelExpandedBody = document.getElementById("order-panel-expanded-body");
    const orderPanelExpandedFooter = document.getElementById("order-panel-expanded-footer");
    const mobileCartSummary = document.getElementById("mobile-cart-summary");
    const mobileCartTotal = document.getElementById("mobile-cart-total");

    let mobileExpanded = false;

    // Format currency
    function formatCurrency(amount) {
      return "$" + (amount || 0).toFixed(2);
    }

    // Render a single order item
    function renderOrderItem(item) {
      const div = document.createElement("div");
      div.className = "order-item";

      const qty = item.quantity || 1;
      const name = item.display_name || item.menu_item_name || item.name || "Item";

      // Check if item has modifiers breakdown (bagels with add-ons)
      const hasModifiers = item.modifiers && item.modifiers.length > 0;

      let html = "";

      if (hasModifiers && (item.item_type === "bagel" || item.item_type === "menu_item")) {
        // Item with modifiers - show base price, then each modifier
        // Works for bagels and menu items (omelettes with side bagel spreads)
        const basePrice = item.base_price || (item.unit_price - item.modifiers.reduce((sum, m) => sum + (m.price || 0), 0));

        html += `
          <div class="order-item-header">
            <span class="order-item-name">${qty > 1 ? qty + "x " : ""}${name}</span>
            <span class="order-item-price">${formatCurrency(basePrice)}</span>
          </div>
        `;

        // Render each modifier with its price (skip $0 prices)
        html += `<div class="order-item-modifiers">`;
        for (const mod of item.modifiers) {
          const priceHtml = mod.price > 0 ? formatCurrency(mod.price) : '';
          html += `
            <div class="order-item-modifier">
              <span class="order-item-modifier-name">${mod.name}</span>
              <span class="order-item-modifier-price">${priceHtml}</span>
            </div>
          `;
        }
        html += `</div>`;
      } else {
        // Standard item - show total price
        const price = item.line_total || item.price || 0;
        html += `
          <div class="order-item-header">
            <span class="order-item-name">${qty > 1 ? qty + "x " : ""}${name}</span>
            <span class="order-item-price">${formatCurrency(price)}</span>
          </div>
        `;

        // Item details (customizations) for non-bagel items
        const details = [];
        if (item.bread) details.push(item.bread);
        if (item.protein) details.push(item.protein);
        if (item.cheese) details.push(item.cheese);

        // Coffee/drink details from item_config
        const config = item.item_config || {};
        if (config.style) details.push(config.style);  // "hot" or "iced"
        if (item.size || config.size) details.push(item.size || config.size);
        if (config.milk && config.milk.toLowerCase() !== "none" && config.milk.toLowerCase() !== "black") {
          details.push(config.milk + " milk");
        } else if (config.milk && (config.milk.toLowerCase() === "none" || config.milk.toLowerCase() === "black")) {
          details.push("black");
        } else if (item.milk) {
          details.push(item.milk + " milk");
        }
        if (config.flavor_syrup) details.push(config.flavor_syrup + " syrup");
        if (config.sweetener) {
          const qty = config.sweetener_quantity || 1;
          if (qty > 1) {
            details.push(`${qty} ${config.sweetener}s`);
          } else {
            details.push(config.sweetener);
          }
        }

        if (item.toppings && item.toppings.length > 0) {
          details.push(item.toppings.join(", "));
        }
        if (item.sauces && item.sauces.length > 0) {
          details.push(item.sauces.join(", "));
        }
        if (item.toasted) details.push("Toasted");
        if (item.spread) details.push(item.spread);

        if (details.length > 0) {
          html += `<div class="order-item-details">${details.join(" ¬∑ ")}</div>`;
        }
      }

      // Special instructions / notes
      if (item.notes || item.special_instructions) {
        html += `<div class="order-item-note">"${item.notes || item.special_instructions}"</div>`;
      }

      div.innerHTML = html;
      return div;
    }

    // Render the full order panel
    function renderOrderPanel(state) {
      if (!state) return;

      const items = state.items || [];
      const hasItems = items.length > 0;

      // Show/hide empty state vs items
      orderEmpty.style.display = hasItems ? "none" : "block";
      orderItemsContainer.style.display = hasItems ? "block" : "none";
      orderPanelFooter.style.display = hasItems ? "block" : "none";

      if (!hasItems) {
        // Update mobile collapsed bar
        mobileCartSummary.textContent = "Cart empty";
        mobileCartTotal.textContent = "$0.00";
        return;
      }

      // Render items list
      orderItemsList.innerHTML = "";
      items.forEach(item => {
        orderItemsList.appendChild(renderOrderItem(item));
      });

      // Order type badge
      const orderType = state.order_type;
      if (orderType) {
        orderTypeBadge.style.display = "inline-flex";
        if (orderType === "delivery") {
          orderTypeBadge.classList.add("delivery");
          orderTypeBadge.querySelector(".icon").textContent = "üöó";
          orderTypeText.textContent = "Delivery";
        } else {
          orderTypeBadge.classList.remove("delivery");
          orderTypeBadge.querySelector(".icon").textContent = "üè™";
          orderTypeText.textContent = "Pickup";
        }
      } else {
        orderTypeBadge.style.display = "none";
      }

      // Calculate totals from checkout_state if available
      const checkout = state.checkout_state || {};
      const subtotal = checkout.subtotal || state.total_price || items.reduce((sum, i) => sum + (i.line_total || i.price || 0), 0);
      const cityTax = checkout.city_tax || 0;
      const stateTax = checkout.state_tax || 0;
      const deliveryFee = checkout.delivery_fee || 0;
      const total = checkout.total || (subtotal + cityTax + stateTax + deliveryFee);

      // Update totals
      orderSubtotal.textContent = formatCurrency(subtotal);

      // Show city tax if > 0
      if (cityTax > 0) {
        orderCityTaxRow.style.display = "flex";
        orderCityTax.textContent = formatCurrency(cityTax);
      } else {
        orderCityTaxRow.style.display = "none";
      }

      // Show state tax if > 0
      if (stateTax > 0) {
        orderStateTaxRow.style.display = "flex";
        orderStateTax.textContent = formatCurrency(stateTax);
      } else {
        orderStateTaxRow.style.display = "none";
      }

      if (deliveryFee > 0) {
        orderDeliveryRow.style.display = "flex";
        orderDeliveryFee.textContent = formatCurrency(deliveryFee);
      } else {
        orderDeliveryRow.style.display = "none";
      }

      orderTotalEl.textContent = formatCurrency(total);

      // Order status
      if (state.status === "confirmed") {
        orderStatusBadge.style.display = "block";
        orderStatusBadge.className = "order-status confirmed";
        orderStatusBadge.textContent = "‚úì Order Confirmed!";
      } else {
        orderStatusBadge.style.display = "none";
      }

      // Customer info
      const customer = state.customer || {};
      if (customer.name || customer.phone || state.delivery_address) {
        orderCustomer.style.display = "block";

        if (customer.name) {
          customerNameEl.textContent = customer.name;
          document.getElementById("customer-name-row").style.display = "flex";
        } else {
          document.getElementById("customer-name-row").style.display = "none";
        }

        if (customer.phone) {
          customerPhoneEl.textContent = customer.phone;
          customerPhoneRow.style.display = "flex";
        } else {
          customerPhoneRow.style.display = "none";
        }

        if (state.delivery_address) {
          customerAddressEl.textContent = state.delivery_address;
          customerAddressRow.style.display = "flex";
        } else {
          customerAddressRow.style.display = "none";
        }
      } else {
        orderCustomer.style.display = "none";
      }

      // Update mobile collapsed bar
      mobileCartSummary.textContent = `${items.length} item${items.length !== 1 ? "s" : ""}`;
      mobileCartTotal.textContent = formatCurrency(total);

      // Sync mobile expanded content
      syncMobileExpandedContent();
    }

    // Sync mobile expanded panel with desktop content
    function syncMobileExpandedContent() {
      // Clone items content for mobile
      orderPanelExpandedBody.innerHTML = orderItemsContainer.innerHTML;

      // Clone footer content for mobile
      orderPanelExpandedFooter.innerHTML = orderPanelFooter.innerHTML;
    }

    // Mobile expand/collapse handlers
    function expandMobilePanel() {
      mobileExpanded = true;
      orderPanelExpanded.classList.add("active");
      orderPanelOverlay.classList.add("active");
      document.body.style.overflow = "hidden"; // Prevent background scroll
    }

    function collapseMobilePanel() {
      mobileExpanded = false;
      orderPanelExpanded.classList.remove("active");
      orderPanelOverlay.classList.remove("active");
      document.body.style.overflow = ""; // Restore scrolling
    }

    // Mobile event listeners
    orderPanelCollapsed.addEventListener("click", () => {
      if (!mobileExpanded) {
        expandMobilePanel();
      }
    });

    orderPanelOverlay.addEventListener("click", collapseMobilePanel);

    document.getElementById("order-panel-expanded-header").addEventListener("click", collapseMobilePanel);

    // Update order panel when orderState changes
    // Hook into existing code that updates orderState
    const originalOrderStateUpdate = function(newState) {
      orderState = newState;
      renderOrderPanel(orderState);
    };

    // Override places where orderState is updated
    // Non-streaming response
    const origSendMessageNonStreaming = sendMessageNonStreaming;
    sendMessageNonStreaming = async function(text) {
      await origSendMessageNonStreaming(text);
      renderOrderPanel(orderState);
    };

    // Streaming response - patch to update panel
    const origSendMessageStreaming = sendMessageStreaming;
    sendMessageStreaming = async function(text) {
      await origSendMessageStreaming(text);
      renderOrderPanel(orderState);
    };

    // Initial render (empty state)
    renderOrderPanel(orderState);

    console.log("[Order Panel] Initialized");
  </script>
</body>
</html>
