<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sammy the Sandwich Bot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
    }
    .app-header {
      background: #1976d2;
      color: white;
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 18px;
      font-weight: 600;
    }
    .app-header span.sub {
      font-size: 13px;
      font-weight: 400;
      opacity: 0.9;
    }
    .chat-container {
      max-width: 900px;
      margin: 20px auto;
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      height: calc(100vh - 80px);
      overflow: hidden;
    }
    .chat-header {
      padding: 10px 16px;
      text-align: center;
      font-size: 13px;
      color: #666;
      border-bottom: 1px solid #eee;
    }
    .chat-messages {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      background: #fafafa;
    }
    .msg-row {
      display: flex;
      margin-bottom: 10px;
    }
    .msg-row.user {
      justify-content: flex-end;
    }
    .msg-row.assistant {
      justify-content: flex-start;
    }
    .msg-bubble {
      max-width: 70%;
      padding: 10px 14px;
      border-radius: 16px;
      font-size: 14px;
      line-height: 1.4;
    }
    .msg-row.user .msg-bubble {
      background: #1976d2;
      color: white;
      border-bottom-right-radius: 4px;
    }
    .msg-row.assistant .msg-bubble {
      background: white;
      border: 1px solid #e0e0e0;
      border-bottom-left-radius: 4px;
    }
    .chat-footer {
      border-top: 1px solid #eee;
      padding: 10px;
      display: flex;
      gap: 8px;
      background: #fff;
    }
    .chat-footer input[type="text"] {
      flex: 1;
      border-radius: 20px;
      border: 1px solid #ccc;
      padding: 8px 12px;
      font-size: 14px;
      outline: none;
    }
    .chat-footer button {
      border-radius: 20px;
      border: none;
      background: #1976d2;
      color: white;
      padding: 0 18px;
      font-size: 14px;
      cursor: pointer;
    }
    .chat-footer button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    .status-bar {
      font-size: 12px;
      color: #777;
      padding: 4px 16px 8px;
    }
    /* Caller ID simulation */
    .caller-id-panel {
      padding: 10px 16px;
      background: #fff3cd;
      border-bottom: 1px solid #ffc107;
      font-size: 13px;
    }
    .caller-id-panel summary {
      cursor: pointer;
      color: #856404;
      font-weight: 500;
    }
    .caller-id-panel summary:hover {
      text-decoration: underline;
    }
    .caller-id-content {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .caller-id-content input {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 13px;
    }
    .caller-id-content button {
      padding: 6px 12px;
      background: #ffc107;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
    }
    .caller-id-content button:hover {
      background: #e0a800;
    }
    .returning-customer-badge {
      background: #28a745;
      color: white;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 11px;
      margin-left: 8px;
    }
    /* Typing indicator styles */
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 10px 14px;
    }
    .typing-indicator .dot {
      width: 8px;
      height: 8px;
      background: #999;
      border-radius: 50%;
      animation: typing-bounce 1.4s infinite ease-in-out both;
    }
    .typing-indicator .dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-indicator .dot:nth-child(2) { animation-delay: -0.16s; }
    .typing-indicator .dot:nth-child(3) { animation-delay: 0s; }
    @keyframes typing-bounce {
      0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
      40% { transform: scale(1); opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="app-header">
    <div>Sammy the Sandwich Bot</div>
    <span class="sub">Demo web chat Â· Local FastAPI backend</span>
  </div>

  <div class="chat-container">
    <!-- Caller ID Simulation Panel (Dev/Demo Mode) -->
    <details class="caller-id-panel" id="caller-id-panel">
      <summary>Simulate Incoming Call (Dev Mode)</summary>
      <div class="caller-id-content">
        <label for="store-select" style="white-space: nowrap;">Store:</label>
        <select id="store-select" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
          <!-- Populated dynamically from localStorage -->
        </select>
      </div>
      <div class="caller-id-content" style="margin-top: 8px;">
        <input
          type="tel"
          id="caller-id-input"
          placeholder="Enter phone number (e.g., 555-123-4567)"
        />
        <button type="button" id="start-with-caller-id">Start Call</button>
      </div>
      <div style="margin-top: 6px; color: #666; font-size: 12px;">
        Select a store and optionally enter a phone number. URL params: <code>?store=store_eb_001&caller_id=555-123-4567</code>
      </div>
    </details>

    <div class="chat-header" id="chat-header">
      Connecting...
    </div>
    <div class="chat-messages" id="chat-messages"></div>
    <div class="status-bar" id="status-bar">Disconnected</div>
    <form class="chat-footer" id="chat-form">
      <input
        type="text"
        id="chat-input"
        autocomplete="off"
        placeholder="Type your message..."
      />
      <button type="submit">Send</button>
    </form>
  </div>

  <script>
    const messagesEl = document.getElementById("chat-messages");
    const headerEl = document.getElementById("chat-header");
    const statusEl = document.getElementById("status-bar");
    const formEl = document.getElementById("chat-form");
    const inputEl = document.getElementById("chat-input");
    const callerIdPanel = document.getElementById("caller-id-panel");
    const callerIdInput = document.getElementById("caller-id-input");
    const storeSelect = document.getElementById("store-select");
    const startWithCallerIdBtn = document.getElementById("start-with-caller-id");

    // Storage key (same as admin_stores.html)
    const STORES_STORAGE_KEY = "sandwich_bot_stores";

    // Default stores (fallback if localStorage is empty)
    const DEFAULT_STORES = [
      { id: "store_eb_001", name: "Sammy's Subs - East Brunswick", status: "open" },
      { id: "store_nb_002", name: "Sammy's Subs - New Brunswick", status: "open" },
      { id: "store_pr_003", name: "Sammy's Subs - Princeton", status: "open" }
    ];

    // Store name mapping (built dynamically)
    let STORE_NAMES = {};

    // Load stores from localStorage and populate dropdown
    function loadStoresAndPopulateDropdown() {
      let stores = [];
      const stored = localStorage.getItem(STORES_STORAGE_KEY);
      if (stored) {
        stores = JSON.parse(stored);
      } else {
        stores = DEFAULT_STORES;
      }

      // Filter: only active (non-deleted) and open stores
      const availableStores = stores.filter(s => !s.deletedAt && s.status !== "closed");

      // Build STORE_NAMES mapping
      STORE_NAMES = {};
      availableStores.forEach(store => {
        // Extract short name (e.g., "East Brunswick" from "Sammy's Subs - East Brunswick")
        const shortName = store.name.includes(" - ")
          ? store.name.split(" - ").pop()
          : store.name;
        STORE_NAMES[store.id] = shortName;
      });

      // Populate dropdown
      storeSelect.innerHTML = "";
      if (availableStores.length === 0) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No stores available";
        storeSelect.appendChild(opt);
      } else {
        availableStores.forEach(store => {
          const opt = document.createElement("option");
          opt.value = store.id;
          opt.textContent = STORE_NAMES[store.id];
          storeSelect.appendChild(opt);
        });
      }

      return availableStores;
    }

    let sessionId = null;
    let connected = false;
    let currentCallerId = null;
    let currentStoreId = null;

    let typingIndicatorEl = null;

    // Analytics tracking
    let sessionStartTime = null;
    let messageCount = 0;
    let orderState = { status: "pending", items: [], total_price: 0 };
    let lastBotMessage = null;
    let lastUserMessage = null;
    let orderConfirmed = false;
    let conversationHistory = [];  // Track full conversation for analytics

    function addMessage(role, text) {
      const row = document.createElement("div");
      row.className = "msg-row " + role;

      const bubble = document.createElement("div");
      bubble.className = "msg-bubble";
      bubble.textContent = text;

      row.appendChild(bubble);
      messagesEl.appendChild(row);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function showTypingIndicator() {
      if (typingIndicatorEl) return; // Already showing

      const row = document.createElement("div");
      row.className = "msg-row assistant";

      const bubble = document.createElement("div");
      bubble.className = "msg-bubble typing-indicator";
      bubble.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';

      row.appendChild(bubble);
      messagesEl.appendChild(row);
      messagesEl.scrollTop = messagesEl.scrollHeight;

      typingIndicatorEl = row;
    }

    function hideTypingIndicator() {
      if (typingIndicatorEl) {
        typingIndicatorEl.remove();
        typingIndicatorEl = null;
      }
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    async function startSession(callerId = null, storeId = null) {
      try {
        setStatus("Starting session...");

        // Build URL with optional parameters
        let url = "/chat/start";
        const params = new URLSearchParams();
        if (callerId) {
          params.append("caller_id", callerId);
          currentCallerId = callerId;
        }
        if (storeId) {
          params.append("store_id", storeId);
          currentStoreId = storeId;
        }
        if (params.toString()) {
          url += "?" + params.toString();
        }

        const resp = await fetch(url, {
          method: "POST",
        });
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        const data = await resp.json();
        sessionId = data.session_id;
        connected = true;
        sessionStartTime = Date.now();

        // Update header with store and caller ID info
        let headerText = "Session: " + sessionId.substring(0, 8);
        if (storeId && STORE_NAMES[storeId]) {
          headerText += ` | ${STORE_NAMES[storeId]}`;
        }
        if (callerId) {
          headerText += ` | Caller: ${callerId}`;
        }
        if (data.returning_customer && data.returning_customer.name) {
          headerText += ` | ${data.returning_customer.name}`;
          // Add returning customer badge
          headerEl.innerHTML = headerText + '<span class="returning-customer-badge">Returning Customer</span>';
        } else {
          headerEl.textContent = headerText;
        }

        setStatus("Connected");

        // Collapse the caller ID panel after starting
        callerIdPanel.removeAttribute("open");

        // ðŸ”¹ Show Sammy's initial greeting from backend
        if (data.message) {
          addMessage("assistant", data.message);
          lastBotMessage = data.message;
          messageCount++;
          conversationHistory.push({ role: "assistant", content: data.message });
        }

        // Log returning customer info if present
        if (data.returning_customer) {
          console.log("Returning customer:", data.returning_customer);
        }
      } catch (err) {
        console.error("Error starting session:", err);
        headerEl.textContent = "Error starting session";
        setStatus("Failed to connect");
      }
    }

    async function sendMessage(text) {
      if (!sessionId) {
        console.warn("No sessionId yet");
        return;
      }
      addMessage("user", text);
      lastUserMessage = text;
      messageCount++;
      conversationHistory.push({ role: "user", content: text });
      setStatus("Sending...");
      showTypingIndicator();

      try {
        const resp = await fetch("/chat/message", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId, message: text }),
        });
        hideTypingIndicator();
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        const data = await resp.json();
        if (data.reply) {
          addMessage("assistant", data.reply);
          lastBotMessage = data.reply;
          messageCount++;
          conversationHistory.push({ role: "assistant", content: data.reply });
        }
        // Track order state for analytics
        if (data.order_state) {
          orderState = data.order_state;
          if (orderState.status === "confirmed") {
            orderConfirmed = true;
          }
        }
        setStatus("Connected");
      } catch (err) {
        hideTypingIndicator();
        console.error("Error sending message:", err);
        addMessage("assistant", "Oops, something went wrong talking to the backend.");
        setStatus("Backend error");
      }
    }

    formEl.addEventListener("submit", (e) => {
      e.preventDefault();
      const text = inputEl.value.trim();
      if (!text) return;
      inputEl.value = "";
      sendMessage(text);
    });

    // Handle "Start Call" button click with caller ID and store
    startWithCallerIdBtn.addEventListener("click", () => {
      const callerId = callerIdInput.value.trim();
      const storeId = storeSelect.value;

      // Reset session state if we already had a session
      if (sessionId) {
        sessionId = null;
        connected = false;
        messagesEl.innerHTML = "";
        messageCount = 0;
        orderState = { status: "pending", items: [], total_price: 0 };
        lastBotMessage = null;
        lastUserMessage = null;
        orderConfirmed = false;
        conversationHistory = [];
        abandonAnalyticsSent = false;
      }
      startSession(callerId || null, storeId);
    });

    // Start session on page load - check URL params first
    window.addEventListener("load", () => {
      // Load stores from localStorage and populate dropdown
      const availableStores = loadStoresAndPopulateDropdown();

      const urlParams = new URLSearchParams(window.location.search);
      const storeIdParam = urlParams.get("store") || urlParams.get("store_id");
      const callerIdParam = urlParams.get("caller_id");

      // Set dropdown value if store param provided and store is available
      if (storeIdParam && STORE_NAMES[storeIdParam]) {
        storeSelect.value = storeIdParam;
      }

      // Set caller ID input if provided
      if (callerIdParam) {
        callerIdInput.value = callerIdParam;
      }

      // Start session with params (store defaults to first option if not specified)
      const storeId = storeIdParam && STORE_NAMES[storeIdParam] ? storeIdParam : storeSelect.value;
      if (storeId) {
        startSession(callerIdParam || null, storeId);
      } else {
        headerEl.textContent = "No stores available";
        setStatus("Please add stores in Store Management");
      }
    });

    // Track abandoned sessions (simulates "hang up")
    let abandonAnalyticsSent = false;  // Prevent duplicate sends

    function sendAbandonAnalytics(reason) {
      // Don't send if already sent, no session, or order was confirmed
      if (abandonAnalyticsSent || !sessionId || orderConfirmed) {
        return;
      }

      abandonAnalyticsSent = true;  // Mark as sent to prevent duplicates

      const items = orderState.items || [];
      const sessionDuration = sessionStartTime
        ? Math.floor((Date.now() - sessionStartTime) / 1000)
        : null;

      const payload = {
        session_id: sessionId,
        message_count: messageCount,
        had_items_in_cart: items.length > 0,
        item_count: items.length,
        cart_total: orderState.total_price || 0,
        order_status: orderState.status || "pending",
        last_bot_message: lastBotMessage,
        last_user_message: lastUserMessage,
        reason: reason,
        session_duration_seconds: sessionDuration,
        conversation_history: conversationHistory,  // Include full conversation
        store_id: currentStoreId,  // Include store for analytics
      };

      // Use sendBeacon for reliability during page unload
      // It's fire-and-forget and works even when the page is closing
      const blob = new Blob([JSON.stringify(payload)], { type: "application/json" });
      navigator.sendBeacon("/chat/abandon", blob);

      console.log("Abandon analytics sent:", reason);
    }

    // Detect page unload (refresh, close, or navigation)
    // Use only beforeunload as it's most reliable and fires first
    window.addEventListener("beforeunload", (event) => {
      // Detect if this is a refresh vs close/navigation
      // Note: We can't perfectly distinguish close vs navigation in beforeunload
      sendAbandonAnalytics("browser_close");
    });
  </script>
</body>
</html>
